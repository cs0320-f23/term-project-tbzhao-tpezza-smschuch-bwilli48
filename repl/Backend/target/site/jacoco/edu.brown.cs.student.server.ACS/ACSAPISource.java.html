<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ACSAPISource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s0</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.server.ACS</a> &gt; <span class="el_source">ACSAPISource.java</span></div><h1>ACSAPISource.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.server.ACS;

import static spark.Spark.connect;

import com.squareup.moshi.JsonAdapter;
import com.squareup.moshi.Moshi;
import edu.brown.cs.student.CSVCode.Search.ColumnIdentifier;
import edu.brown.cs.student.CSVCode.Search.Search;
import edu.brown.cs.student.server.Caching.CachedItems;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.List;
import okio.Buffer;

/**
 * This is the ACSAPISource class. It implements the BroadbandDataSource interface and is
 * responsible for making calls to the API and handling the data received, as well as interactions
 * with the cache.
 */
public class ACSAPISource implements BroadbandDataSource {
  CachedItems cache;
  StateIds states;

  /**
   * This is the constructor for the class. It associates the cache and collection holding states to
   * IDs.
   *
   * @param cache A cache containing data that is already requested
   * @param states A collection containing references to IDs from state names
   */
  public ACSAPISource(CachedItems cache, StateIds states) {
    this.cache = cache;
<span class="fc" id="L35">    this.states = states;</span>
<span class="fc" id="L36">  }</span>
<span class="fc" id="L37"></span>
<span class="fc" id="L38">  /**</span>
   * This method makes a call to the API. It checks for various exceptions that might result from
   * the connection or data received. It forms a connections, accesses the API through the URL, and
   * converts data from all the states to state codes into a form that we can use. If the request
   * has not been made yet, it saves the data into the cache. Otherwise, it checks the cache for the
   * requested data.
   *
   * @param states The collection holding references to IDs from state names
   * @param stateName The state name to be searched
   * @return The ID of the state that is searched
   * @throws DatasourceException An exception thrown in the case of a bad request, or malformed data
   */
  private static String resolveStateID(StateIds states, String stateName)
      throws DatasourceException {
    try {
      if (states.isStateToIdsEmpty()) {
        URL requestURL =
            new URL(&quot;https&quot;, &quot;api.census.gov&quot;, &quot;/data/2010/dec/sf1?get=NAME&amp;for=state:*&quot;);
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        HttpURLConnection clientConnection = connect(requestURL);</span>
<span class="fc" id="L57">        Moshi moshi = new Moshi.Builder().build();</span>
        JsonAdapter&lt;List&gt; jsonAdapter = moshi.adapter(List.class);
<span class="fc" id="L59">        List&lt;List&lt;String&gt;&gt; body =</span>
<span class="fc" id="L60">            jsonAdapter.fromJson(new Buffer().readFrom(clientConnection.getInputStream()));</span>
<span class="fc" id="L61">        clientConnection.disconnect();</span>
<span class="fc" id="L62">        Search search =</span>
<span class="fc" id="L63">            new Search(body, stateName, ColumnIdentifier.Identifier.NONE, &quot;&quot;, true, false);</span>
<span class="fc" id="L64">        List&lt;List&lt;String&gt;&gt; stateRow = search.searchParsed();</span>
<span class="fc" id="L65">        if (stateRow.isEmpty()) {</span>
<span class="fc" id="L66">          throw new DatasourceException(&quot;State not found&quot;);</span>
<span class="fc" id="L67">        }</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        states.setStatesToIds(body);</span>
<span class="fc" id="L69">        String stateID = stateRow.get(0).get(1);</span>
        if (body == null) throw new DatasourceException(&quot;Malformed response from ACS&quot;);
<span class="fc" id="L71"></span>
<span class="fc" id="L72">        return stateID;</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">      } else {</span>
        Search search =
<span class="fc" id="L75">            new Search(</span>
                states.getStatesToIds(),
<span class="nc" id="L77">                stateName,</span>
                ColumnIdentifier.Identifier.NONE,
<span class="nc" id="L79">                &quot;&quot;,</span>
                true,
                false);
        String stateID = search.searchParsed().get(0).get(1);
<span class="nc" id="L83">        return stateID;</span>
<span class="nc" id="L84">      }</span>
<span class="nc" id="L85">    } catch (IOException e) {</span>
<span class="nc" id="L86">      throw new DatasourceException(e.getMessage());</span>
    }
<span class="nc" id="L88">  }</span>
<span class="nc" id="L89"></span>
  /**
   * A similar method to the previous, this method handles the request for the county ID. The metod
   * also forms a connections via a url, then returns it in a list of list of strings to be searched
   * for the desired county ID. If the cache contains the state and county already, it retreives it
   * from the cache.
   *
   * @param cache The cache containing previously made requests.
   * @param stateID The state ID for the state in which the counties are searched
   * @param countyName The name of the country to be searched for
   * @param stateName The state to be searched in
   * @return The county ID that is found
   * @throws DatasourceException An exception thrown if a county is not found or a bad request or
   *     bad datasource is used.
   */
  private static String resolveCountyID(
      CachedItems cache, String stateID, String countyName, String stateName)
      throws DatasourceException {
    try {
      if (!cache.checkCounty(countyName)) {
        URL requestURL =
            new URL(
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">                &quot;https&quot;,</span>
<span class="fc" id="L112">                &quot;api.census.gov&quot;,</span>
                &quot;/data/2010/dec/sf1?get=NAME&amp;for=county:*&amp;in=state:&quot; + stateID);
        HttpURLConnection clientConnection = connect(requestURL);
        Moshi moshi = new Moshi.Builder().build();
        JsonAdapter&lt;List&gt; jsonAdapter = moshi.adapter(List.class);
<span class="fc" id="L117">        List&lt;List&lt;String&gt;&gt; body =</span>
<span class="fc" id="L118">            jsonAdapter.fromJson(new Buffer().readFrom(clientConnection.getInputStream()));</span>
<span class="fc" id="L119">        clientConnection.disconnect();</span>
<span class="fc" id="L120">        Search search =</span>
<span class="fc" id="L121">            new Search(</span>
<span class="fc" id="L122">                body,</span>
<span class="fc" id="L123">                countyName + &quot;, &quot; + stateName,</span>
                ColumnIdentifier.Identifier.NONE,
                &quot;&quot;,
                true,
                false);
        List&lt;List&lt;String&gt;&gt; countyRow = search.searchParsed();
<span class="fc" id="L129">        if (countyRow.isEmpty()) {</span>
<span class="fc" id="L130">          throw new DatasourceException(&quot;County not found&quot;);</span>
<span class="fc" id="L131">        }</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        String countyID = countyRow.get(0).get(2);</span>
<span class="fc" id="L133">        if (body == null) throw new DatasourceException(&quot;Malformed response from ACS&quot;);</span>
        return countyID;
<span class="fc" id="L135">      } else {</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        String countyID = cache.getInfo(countyName).get(0).get(2);</span>
<span class="fc" id="L137">        return countyID;</span>
      }
<span class="nc" id="L139">    } catch (IOException e) {</span>
<span class="nc" id="L140">      throw new DatasourceException(e.getMessage());</span>
    }
<span class="nc" id="L142">  }</span>
<span class="nc" id="L143"></span>
  /**
   * This method deals with forming the connection with the API. It is a helper called to form the
   * connection and returns it to be used by the resolve methods.
   *
   * @param requestURL The requested URL from the API that is passed in
   * @return The connection to the API
   * @throws IOException Exception thrown in the try catch used to then throw a DatasourceException
   * @throws DatasourceException Exception thrown in cases of bad input, connection, or unexpected
   *     results.
   */
  private static HttpURLConnection connect(URL requestURL) throws IOException, DatasourceException {
    URLConnection urlConnection = requestURL.openConnection();
    if (!(urlConnection instanceof HttpURLConnection)) {
<span class="fc" id="L157">      throw new DatasourceException(&quot;unexpected: result of connection wasn't HTTP&quot;);</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">    }</span>
<span class="nc" id="L159">    HttpURLConnection clientConnection = (HttpURLConnection) urlConnection;</span>
    clientConnection.connect();
<span class="fc" id="L161">    if (clientConnection.getResponseCode() != 200) {</span>
<span class="fc" id="L162">      throw new DatasourceException(</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">          // Only ever found when county is too small</span>
<span class="fc" id="L164">          &quot;County too small&quot;);</span>
    }
    return clientConnection;
  }
<span class="fc" id="L168"></span>
  /**
   * Method used to resolve the percentage of broadband coverage at a certain state and county ID.
   * This either makes a new request or checks the cache to retrieve the percentage based on the IDs
   * passed in.
   *
   * @param cache The cache containing past queries that is passed in
   * @param stateID The ID of the state to be searched
   * @param countyID The ID of the county to be searched
   * @param countyName The county name of the county that is searched
   * @return Returns the percentage of broadband coverage in record form
   * @throws DatasourceException Exception thrown in the case of unexpected results, input, or
   *     connections.
   */
  private static BroadbandData percentageAtID(
      CachedItems cache, String stateID, String countyID, String countyName)
      throws DatasourceException {
    try {
      if (!cache.checkCounty(countyName)) {
        URL requestURL =
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            new URL(</span>
<span class="fc" id="L189">                &quot;https&quot;,</span>
                &quot;api.census.gov&quot;,
                &quot;/data/2021/acs/acs1/subject/variables?get=NAME,S2802_C03_022E&amp;for=county:&quot;
                    + countyID
                    + &quot;&amp;in=state:&quot;
                    + stateID);
        HttpURLConnection clientConnection = connect(requestURL);
        Moshi moshi = new Moshi.Builder().build();
<span class="fc" id="L197">        JsonAdapter&lt;List&gt; jsonAdapter = moshi.adapter(List.class);</span>
<span class="fc" id="L198">        List&lt;List&lt;String&gt;&gt; body =</span>
<span class="fc" id="L199">            jsonAdapter.fromJson(new Buffer().readFrom(clientConnection.getInputStream()));</span>
<span class="fc" id="L200">        clientConnection.disconnect();</span>
<span class="fc" id="L201">        if (body == null) throw new DatasourceException(&quot;Malformed response from ACS&quot;);</span>
<span class="fc" id="L202">        cache.addCounty(countyName, body);</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        cache.addFrequency(countyName);</span>
<span class="fc" id="L204">        return new BroadbandData(body.get(1).get(1));</span>
<span class="fc" id="L205">      } else {</span>
<span class="fc" id="L206">        cache.addFrequency(countyName);</span>
        return new BroadbandData(cache.getInfo(countyName).get(1).get(1));
<span class="nc" id="L208">      }</span>
<span class="nc" id="L209">    } catch (IOException e) {</span>
      throw new DatasourceException(e.getMessage());
<span class="nc" id="L211">    }</span>
<span class="nc" id="L212">  }</span>

  /**
   * Interface method that is utilized by this class to consolidate and produce a percentage in
   * record form. Calls methods to resolve state and county IDs, takes in a location to be searched
   * for, and calls the percentage method to return a final result.
   *
   * @param location Location including state and county to be searched for.
   * @return Percentage of broadband coverage in record form
   * @throws DatasourceException Exception thrown by the helper methods for bad data, requests, or
   *     unexpected results
   */
  @Override
  public BroadbandData getBroadbandData(Location location) throws DatasourceException {
    String stateID = resolveStateID(this.states, location.state());
    String countyID = resolveCountyID(this.cache, stateID, location.county(), location.state());
    BroadbandData percentage = percentageAtID(this.cache, stateID, countyID, location.county());
<span class="fc" id="L229">    return percentage;</span>
<span class="fc" id="L230">  }</span>
<span class="fc" id="L231">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>